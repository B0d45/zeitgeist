<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zeiterfassung</title>
    
      <!-- Nostr Tools -->
    <script src="https://unpkg.com/nostr-tools@1.7.0/lib/nostr.bundle.js"></script>


    <!-- jsPDF + autoTable -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/5.0.2/jspdf.plugin.autotable.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

   

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #0a2b2b;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }

        /* Mehr Abstand zwischen den Abschnitten */
        .timer-section,
        .project-section,
        .report-section,
        .login-section,
        .entries-section,
        .donation-section {
            margin-top: 40px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 4px 20px;
            cursor: pointer;
            border-radius: 4px;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        button.delete {
            background-color: #dc3545;
        }
        button.delete:hover {
            background-color: #c82333;
        }
        select, input[type="text"], input[type="date"], input[type="number"] {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            border-radius: 4px;
            background: white;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .timer-display {
            font-size: 24px;
            text-align: center;
            margin: 10px 0;
        }
        .error {
            color: red;
            font-size: 14px;
        }
        .hidden {
            display: none;
        }
        .edit-input {
            width: 100%;
            box-sizing: border-box;
        }
        
        .timer-section, .project-section, .report-section, .login-section, .entries-section, .donation-section {
         background: #e1e1e1ab;
         padding: 15px;
        }
        
        details summary {
    padding: 0.5rem;
    background: #eee;
    border-radius: 8px;
    width: fit-content;
    transition: background 0.2s;
}
details summary:hover {
    background: #ddd;
}
#contactsContainer div {
    padding: 0.3rem 0;
    border-bottom: 1px solid #ccc;
}

#contactsContainer {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 3 gleich breite Spalten */
    gap: 1rem; /* Abstand zwischen den Spalten */
    padding: 0.5rem 0;
}

#contactsContainer div {
    padding: 0.5rem;
    background: #f9f9f9;
    border: 1px solid #ccc;
    border-radius: 8px;
    max-width: 100%;
    word-break: break-word;
    overflow-wrap: break-word;
    box-sizing: border-box;
      overflow: hidden;
  text-overflow: ellipsis;
}

#relaySelect {
  max-width: 100%;
  width: 100%;
  overflow-x: auto;
  box-sizing: border-box;
}

.progress-bar-container {
  background: #e0e0e0;
  border-radius: 30px;
  overflow: hidden;
  height: 20px;
  margin-bottom: 20px;
}

.progress-bar {
  height: 100%;
  background: #4b7bec;
  width: 0%;
  transition: width 0.4s ease;
}


.timeline {
  position: relative;
  margin: 20px 0;
  padding-left: 30px;
  border-left: 2px solid #4b7bec;
}

.timeline li {
  position: relative;
  margin-bottom: 20px;
  padding-left: 12px;
  background: #f0f4f8;
  border-radius: 6px;
  padding: 10px 15px;
}

.timeline li::before {
  content: "";
  position: absolute;
  top: 12px;
  left: -10px;
  width: 12px;
  height: 12px;
  background: #4b7bec;
  border-radius: 50%;
  border: 2px solid white;
}


.two-columns {
  display: flex;
  gap: 30px;
  flex-wrap: wrap;
}

.project-column,
.client-column {
  flex: 1 1 300px;
  min-width: 250px;
}

.project-column ul,
.client-column ul {
  margin-top: 10px;
  padding-left: 20px;
}



    </style>
</head>
<body>
    

<div id="tabMenu" class="hidden" style="background:#eee; padding:10px; text-align:center;">
    <button onclick="switchTab('timeTrackingTab')">‚è±Ô∏è Zeiterfassung</button>
    <button onclick="switchTab('todoTab')">‚úÖ To-do Liste</button>
</div>


<div id="todoTab" class="hidden">
  <div class="container">
    <h1>To-do Liste</h1>

<form onsubmit="addTodo(); return false;" style="margin-bottom: 20px;">
  <input type="text" id="todoTitleInput" placeholder="Neue Aufgabe" required>
  <input type="date" id="todoDueDateInput">
  <select id="todoClientSelect">
    <option value="">üîó Kein Klient</option>
  </select>
  <button type="submit">‚ûï Hinzuf√ºgen</button>
</form>

<!-- Fortschrittsanzeige -->
    <div class="progress-bar-container">
      <div class="progress-bar" id="todoProgress"></div>
    </div>

    <ul id="todoList" class="timeline"></ul>
    </div>
</div>

<div id="timeTrackingTab">

    <div class="container">
        <h1>Zeiterfassung</h1>

        <!-- Login Section -->
        <div class="login-section" id="loginSection">
            <h2>Nostr Login</h2>
            <p>√ñffentlicher Schl√ºssel: <span id="pubkeyDisplay">Nicht eingeloggt</span></p>
            <input type="text" id="customRelayInput" placeholder="Eigenes Relay (z.B. wss://mein-relay.com oder ws://abcdefg.onion)">
            <button onclick="addCustomRelay()">Relay hinzuf√ºgen</button>
            <select id="relaySelect" multiple>
                <option value="wss://nos.lol">wss://nos.lol</option>
                <option value="wss://relay.nostr.band">wss://relay.nostr.band</option>
                <option value="wss://relay.damus.io">wss://relay.damus.io</option>
                <option value="wss://nostr.wine">wss://nostr.wine</option>
                <option value="wss://relay.snort.social">wss://relay.snort.social</option>
                <option value="wss://nostr.fmt.wiz.biz">wss://nostr.fmt.wiz.biz</option>
                <option value="ws://mknqnp5rmmtw7ogxjahpfawfucwltixsvi26rf2urenpvkioawmp3qyd.onion">ws://mknqnp5rmmtw7ogxjahpfawfucwltixsvi26rf2urenpvkioawmp3qyd.onion</option>
            </select>
            <button onclick="loginWithAlby()">Mit Alby einloggen</button>
            <button onclick="generateNostrKeys()">Neue Schl√ºssel generieren</button>
            <p id="generatedKeyDisplay" class="hidden"></p>
            <p class="error" id="loginError"></p>
        </div>







        <!-- Timer Section -->
        <div class="timer-section hidden" id="timerSection">
          
            <div class="timer-display" id="timerDisplay">00:00:00</div>
            <select id="projectSelect">
                <option value="">Kein Projekt ausw√§hlen</option>
            </select>
            <input type="text" id="projectFreeText" placeholder="Projekt (optional)" class="hidden">
            <select id="clientSelect">
                <option value="">Kein Klient ausw√§hlen</option>
            </select>
            <input type="text" id="clientFreeText" placeholder="Klient (optional)" class="hidden">
            <button id="startButton" onclick="startTimer()">Start</button>
            <button id="stopButton" onclick="stopTimer()" disabled>Stop</button>
            <button onclick="toggleProjectClientPanel()">üìÇ Projekte & Klienten</button>
        </div>
        
        
        
        
<div id="projectClientPanel" class="hidden" style="margin-top: 10px;">
  <div class="two-columns">
    <div class="project-column">
      <h3>Projekte</h3>
      <input type="text" id="projectNameInput" placeholder="Projektname">
      <button onclick="addProject()">Projekt hinzuf√ºgen</button>
      <ul id="projectList"></ul>
    </div>

    <div class="client-column">
      <h3>Klienten</h3>
      <input type="text" id="clientNameInput" placeholder="Clientname">
      <button onclick="addClient()">Klient hinzuf√ºgen</button>
      <ul id="clientList"></ul>
    </div>
  </div>
</div>


        
        
        
        

        <!-- Entries Section -->
<div class="entries-section hidden" id="entriesSection">

    <!-- Bulk action controls oben -->
    <div style="margin-bottom: 10px;">
        <button onclick="toggleAllCheckboxes()">Alle ausw√§hlen/abw√§hlen</button>
        <button onclick="deleteSelectedEntries()">Ausgew√§hlte l√∂schen</button>
    </div>

    <table id="entriesTable">
        <thead>
            <tr>
                <th><input type="checkbox" id="selectAllCheckbox" onclick="toggleAllCheckboxes()"></th>
                <th>Datum</th>
                <th>Projekt</th>
                <th>Klient</th>
                <th>Dauer</th>
                <th>Aktion</th>
            </tr>
        </thead>
        <tbody id="entriesBody"></tbody>
    </table>

    <!-- Bulk action controls unten -->
    <div style="margin-top: 10px;">
        <button onclick="toggleAllCheckboxes()">Alle ausw√§hlen/abw√§hlen</button>
        <button onclick="deleteSelectedEntries()">Ausgew√§hlte l√∂schen</button>
    </div>
</div>


        <!-- Project/Client Management -->
        <div class="project-section hidden" id="projectSection">
            <h2>Projekte und Klienten</h2>
            <input type="text" id="projectNameInput" placeholder="Projektname">
            <button onclick="addProject()">Projekt hinzuf√ºgen</button>
            <input type="text" id="clientNameInput" placeholder="Clientname">
            <button onclick="addClient()">Klient hinzuf√ºgen</button>
            <h3>Projekte</h3>
            <ul id="projectList"></ul>
            <h3>Klienten</h3>
            <ul id="clientList"></ul>
        </div>

        <!-- Report Section -->
        <div class="report-section hidden" id="reportSection">
            <h2>Berichte</h2>
            <select id="reportFilter">
                <option value="day">Tag</option>
                <option value="week">Woche</option>
                <option value="month">Monat</option>
            </select>

      <input type="date" id="reportDate">
            <label for="reportProjectFilter" style="margin-left: 10px;">Filter Projekt:</label>
            <select id="reportProjectFilter">
                <option value="all">Alle Projekte</option>
            </select>
            <label for="reportClientFilter" style="margin-left: 10px;">Filter Client:</label>
            <select id="reportClientFilter">
                <option value="all">Alle Klienten</option>
            </select>
            <button onclick="generateReport()">Bericht generieren</button>
            <button onclick="exportToPDF()">PDF Export</button>
            
            <table id="reportTable" class="hidden">
                <thead>
                    <tr>
                        <th>Datum</th>
                        <th>Projekt</th>
                        <th>Klient</th>
                        <th>Dauer</th>
                    </tr>
                </thead>
                <tbody id="reportBody"></tbody>
            </table>
            <p>Gesamtstunden: <span id="totalHours">0</span></p>
        </div>




<section class="hidden" id="contactsSection">
    <h2>Kontakte</h2>
      <div style="margin-bottom: 1rem;">
  <input type="text" id="contactSearchInput" placeholder="üîç Kontakt suchen..." oninput="renderFilteredContacts()" style="padding:5px; width: 200px;">
  <label style="margin-left: 10px;">
    <input type="checkbox" id="filterWithLightning" onclick="renderFilteredContacts()">
    Nur mit ‚ÄûDanke senden‚Äú-Button
  </label>
</div>
    
    <details>
        <summary style="cursor:pointer; font-weight: bold; margin-top: 10px;">Nostr-Kontakte anzeigen</summary>
        <div id="contactsContainer"></div>
    </details>
</section>     
    



      <!-- Donation Section -->
<div class="donation-section hidden" id="donationSection">
    <h2>Spenden</h2>
    <div id="lightningAddressInputContainer">
        <input type="text" id="lightningAddressInput" placeholder="Deine Lightning-Adresse z.B. name@getalby.com">
        <button onclick="saveLightningAddress(event)">Adresse speichern</button>
    </div>
    <!-- Hier zeigen wir die Best√§tigungsnachricht -->
   <p id="lightningAddressConfirmation" class="hidden"></p>
<button id="editLightningAddressButton" class="hidden" onclick="editLightningAddress()">Adresse √§ndern</button>


    <p>Spende hier einige Sats:</p>
    <input type="number" id="donationAmount" placeholder="Betrag in Sats (z.B. 1000)" min="1">
    <button onclick="makeLightningDonation()">Jetzt spenden</button>
    <p class="error" id="donationError"></p>
</div>



        <div class="donation-section hidden" id="donationSection">
            <h2>Spenden</h2>
            <p>Spende hier einige Sats:</p>
            <input type="number" id="donationAmount" placeholder="Betrag in Sats (z.B. 1000)" min="1">
            <button onclick="makeLightningDonation()">Jetzt spenden</button>
            <p class="error" id="donationError"></p>
        </div>
    </div>
    
</div>

    
<button id="publishContactsButton" class="hidden" onclick="publishContactsToPrivateRelay(JSON.parse(localStorage.getItem('myContacts')))">
    Kontakte ans private Relay senden
</button>
  
    
 
    
    

    <script>
        const { jsPDF } = window.jspdf;
        let timerInterval = null;
        let startTime = null;
        let elapsedTime = 0;
        let isLoggedIn = false;
        let publicKey = null;
        let relays = [];
        let pool = null;

   

        // Datenstrukturen
        let timeEntries = JSON.parse(localStorage.getItem('timeEntries')) || [];
        let projects = JSON.parse(localStorage.getItem('projects')) || [];
        let clients = JSON.parse(localStorage.getItem('clients')) || [];
        let allContacts = []; // speichert pubkey + profile


        // Initialisierung
     document.addEventListener('DOMContentLoaded', () => {
            setTodayDate();
            loadCustomRelay();
            updateSelectOptions(); // Diese ist f√ºr die Timer-Dropdowns
            updateReportFilterOptions(); // <-- NEU: Ruft die neue Funktion auf
            updateLists();
            updateEntriesTable();
            console.log('Initialisierte timeEntries:', timeEntries);
            toggleFreeTextFields();
            renderTodos();

            
                // Lightning-Adresse pr√ºfen und UI anpassen
    const savedAddress = localStorage.getItem('lightningAddress');
    if (savedAddress) {
        // Eingabefeld ausblenden
        document.getElementById('lightningAddressInputContainer').classList.add('hidden');

        // Hinweistext einblenden
        const confirmation = document.getElementById('lightningAddressConfirmation');
        confirmation.textContent = `‚úÖ Lightning-Adresse aktiviert (${savedAddress})`;
        confirmation.classList.remove('hidden');
        // NEU: auch den "Adresse √§ndern"-Button zeigen
    document.getElementById('editLightningAddressButton').classList.remove('hidden');
    }
  
        });


function switchTab(tabName) {
    document.getElementById('timeTrackingTab').classList.add('hidden');
    document.getElementById('todoTab').classList.add('hidden');

    document.getElementById(tabName).classList.remove('hidden');
}



function safeParseInt(val) {
    const parsed = parseInt(val);
    return isNaN(parsed) ? null : parsed;
}


function toggleProjectClientPanel() {
  const panel = document.getElementById('projectClientPanel');
  panel.classList.toggle('hidden');
}




function saveData(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
        console.log(`‚úîÔ∏è Lokal gespeichert: ${key}`);
    } catch (err) {
        console.error('üîí Speicherfehler bei localStorage:', err.message);
    }
}







function loginWithAlby() {
    if (!window.nostr) {
        alert("Alby-Erweiterung nicht gefunden. Bitte installiere Alby.");
        return;
    }
    if (!window.NostrTools || !window.NostrTools.SimplePool) {
        alert("NostrTools noch nicht geladen. Bitte Seite neu laden.");
        return;
    }

    window.nostr.getPublicKey()
        .then(pk => {
            publicKey = pk;
            document.getElementById('pubkeyDisplay').textContent = window.NostrTools.nip19.npubEncode(publicKey);
            isLoggedIn = true;

            const relaySelect = document.getElementById('relaySelect');
            relays = Array.from(relaySelect.selectedOptions).map(option => option.value);

            if (relays.length === 0) {
                alert('Bitte mindestens ein Relay ausw√§hlen.');
                return;
            }

            pool = new NostrTools.SimplePool();

            checkRelayHealth(relays)
                .then(workingRelays => {
                    if (workingRelays.length === 0) {
                        alert('‚ùå Keines der gew√§hlten Relays ist erreichbar.');
                        return;
                    }

                    relays = workingRelays;

                    // Lade die Events und aktualisiere die UI,
                    // auch wenn Kontakte fehlschlagen
                    fetchNostrEvents().catch(err => {
                        console.error('Fehler beim Laden der Nostr-Events:', err);
                    });

                    loadMyContactsAndProfiles().catch(err => {
                        console.error('Fehler beim Laden der Kontakte:', err);
                        showStatus('‚ö†Ô∏è Kontakte konnten nicht geladen werden.');
                    });

                    // UI SOFORT umschalten
                    toggleSections();

                })
                .catch(err => {
                    alert('‚ùå Fehler beim Testen der Relays: ' + err.message);
                });

        })
        .catch(err => {
            document.getElementById('loginError').textContent = "Login fehlgeschlagen: " + err.message;
        });

    // Lade lokale Kontakte aus dem Storage (nur Info-Zweck)
    let storedContacts = JSON.parse(localStorage.getItem('myContacts') || '[]');
    if (storedContacts.length === 0) {
        console.log('‚ÑπÔ∏è Keine gespeicherten Kontakte gefunden.');
    }
}




        function addCustomRelay() {
            const customRelayInput = document.getElementById('customRelayInput').value.trim();
            const relaySelect = document.getElementById('relaySelect');

            const isValidRelay = /^(wss:\/\/[a-zA-Z0-9-.]+)|(wss?:\/\/[a-zA-Z0-9-]+\.onion)$/.test(customRelayInput);
            if (isValidRelay) {
                const exists = Array.from(relaySelect.options).some(option => option.value === customRelayInput);
                if (!exists) {
                    const option = document.createElement('option');
                    option.value = customRelayInput;
                    option.text = customRelayInput;
                    option.selected = true;
                    relaySelect.appendChild(option);
                    localStorage.setItem('customRelay', customRelayInput);
                    document.getElementById('loginError').textContent = `Benutzerdefiniertes Relay ${customRelayInput} hinzugef√ºgt.`;
                } else {
                    document.getElementById('loginError').textContent = 'Dieses Relay ist bereits in der Liste.';
                }
            } else {
                document.getElementById('loginError').textContent = 'Bitte eine g√ºltige Relay-URL eingeben (z.B. wss://mein-relay.com oder ws://abcdefg.onion).';
            }
        }

        function loadCustomRelay() {
            const customRelay = localStorage.getItem('customRelay');
            if (customRelay) {
                document.getElementById('customRelayInput').value = customRelay;
                const relaySelect = document.getElementById('relaySelect');
                const option = document.createElement('option');
                option.value = customRelay;
                option.text = customRelay;
                option.selected = true;
                relaySelect.appendChild(option);
            }
        }

        function toggleFreeTextFields() {
            const projectSelect = document.getElementById('projectSelect');
            const clientSelect = document.getElementById('clientSelect');
            const projectFreeText = document.getElementById('projectFreeText');
            const clientFreeText = document.getElementById('clientFreeText');

            projectSelect.addEventListener('change', () => {
                projectFreeText.classList.toggle('hidden', projectSelect.value !== '');
                if (projectSelect.value !== '') projectFreeText.value = '';
            });

            clientSelect.addEventListener('change', () => {
                clientFreeText.classList.toggle('hidden', clientSelect.value !== '');
                if (clientSelect.value !== '') clientFreeText.value = '';
            });
        }

   function updateSelectOptions() {
  const projectSelect = document.getElementById('projectSelect');
  const clientSelect = document.getElementById('clientSelect');
  const reportClientFilter = document.getElementById('reportClientFilter');
  const reportProjectFilter = document.getElementById('reportProjectFilter');
  const todoClientSelect = document.getElementById('todoClientSelect');

  // Projekte
  projectSelect.innerHTML = '<option value="">Kein Projekt ausw√§hlen</option>' +
      projects.map(p => `<option value="${p.id}">${p.name}</option>`).join('');

  if (reportProjectFilter) {
    reportProjectFilter.innerHTML = '<option value="all">Alle Projekte</option>';
    projects.forEach(project => {
      const option = document.createElement('option');
      option.value = project.id;
      option.textContent = project.name;
      reportProjectFilter.appendChild(option);
    });
  }

  // Clients
  const clients = JSON.parse(localStorage.getItem('clients')) || [];
  clientSelect.innerHTML = '<option value="">Kein Klient ausw√§hlen</option>';
  clients.forEach(client => {
    const option = document.createElement('option');
    option.value = client.id;
    option.textContent = client.name;
    clientSelect.appendChild(option);
  });

  if (reportClientFilter) {
    reportClientFilter.innerHTML = '<option value="all">Alle Klienten</option>';
    clients.forEach(client => {
      const option = document.createElement('option');
      option.value = client.id;
      option.textContent = client.name;
      reportClientFilter.appendChild(option);
    });
  }

  if (todoClientSelect) {
    todoClientSelect.innerHTML = '<option value="">üîó Kein Klient</option>';
    clients.forEach(client => {
      const option = document.createElement('option');
      option.value = client.id;
      option.textContent = client.name;
      todoClientSelect.appendChild(option);
    });
  }
}


        function updateLists() {
            const projectList = document.getElementById('projectList');
            const clientList = document.getElementById('clientList');
            projectList.innerHTML = projects.map(p => `<li>${p.name} <button class="delete" onclick="deleteProject(${p.id})">L√∂schen</button></li>`).join('');
            clientList.innerHTML = clients.map(c => `<li>${c.name} <button class="delete" onclick="deleteClient(${c.id})">L√∂schen</button></li>`).join('');
        }


function updateReportFilterOptions() {
    const reportProjectFilter = document.getElementById('reportProjectFilter');
    const reportClientFilter = document.getElementById('reportClientFilter');

    reportProjectFilter.innerHTML = '<option value="all">Alle Projekte</option>' +
        projects.map(p => `<option value="${p.id}">${p.name}</option>`).join('');

    reportClientFilter.innerHTML = '<option value="all">Alle Klienten</option>' +
    clients.map(c => `<option value="${c.id}">${c.name}</option>`).join('');

}



  function updateEntriesTable() {
    const entriesBody = document.getElementById('entriesBody');
    entriesBody.innerHTML = '';

    if (timeEntries.length === 0) {
        entriesBody.innerHTML = '<tr><td colspan="6">Keine Eintr√§ge vorhanden.</td></tr>';
        return;
    }

    const sortedEntries = [...timeEntries].sort((a, b) => b.start - a.start);

    sortedEntries.forEach(entry => {
        const projectDisplay = entry.projectName || entry.projectFreeText || 'Kein Projekt';
        const clientDisplay = entry.clientName || entry.clientFreeText || 'Kein Client';
        const durationFormatted = formatDuration(entry.duration);

        entriesBody.innerHTML += `
            <tr id="entry-${entry.id}">
                <td><input type="checkbox" class="entry-checkbox" data-id="${entry.id}"></td>
                <td>${new Date(entry.start).toLocaleDateString('de-DE')}</td>
                <td class="project-cell">${projectDisplay}</td>
                <td class="client-cell">${clientDisplay}</td>
                <td>${durationFormatted}</td>
                <td>
                    <button onclick="editEntry(${entry.id})">Bearbeiten</button>
                    <button class="delete" onclick="deleteEntry(${entry.id})">L√∂schen</button>
                </td>
            </tr>
        `;
    });
}





function toggleAllCheckboxes() {
    const checkboxes = document.querySelectorAll('.entry-checkbox');
    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
    checkboxes.forEach(cb => cb.checked = !allChecked);
    // auch die Header-Checkbox synchronisieren
    document.getElementById('selectAllCheckbox').checked = !allChecked;
}

function deleteSelectedEntries() {
    const idsToDelete = Array.from(document.querySelectorAll('.entry-checkbox:checked'))
        .map(cb => Number(cb.dataset.id));
    if (idsToDelete.length === 0) {
        alert('Bitte mindestens einen Eintrag ausw√§hlen.');
        return;
    }
    if (!confirm(`M√∂chtest du ${idsToDelete.length} gew√§hlte Zeiteintr√§ge l√∂schen?`)) return;

    idsToDelete.forEach(id => {
        const entryToDelete = timeEntries.find(e => e.id === id);
        timeEntries = timeEntries.filter(e => e.id !== id);
        if (entryToDelete) {
            publishNostrEvent('time-entry-deleted', { id }); // optional Nostr-Event
        }
    });

    saveData('timeEntries', timeEntries);
    updateEntriesTable();
}








   function editEntry(entryId) {
    const entry = timeEntries.find(e => e.id === entryId);
    if (!entry) return;

    const row = document.getElementById(`entry-${entryId}`);
    const projectCell = row.querySelector('.project-cell');
    const clientCell = row.querySelector('.client-cell');
    const durationCell = row.children[4]; // Dauer-Spalte (Index anpassen wenn deine Tabelle anders ist!)

    // Vorhandene Werte
    const projectValue = entry.projectName || '';
    const clientValue = entry.clientName || '';
    const clientFreeTextValue = entry.clientFreeText || '';
    const durationValue = formatDuration(entry.duration);

    // Projekttextfeld
    projectCell.innerHTML = `<input type="text" class="edit-input project-input" value="${projectValue}">`;

    // Klientenauswahl + Freitext
    let clientOptions = '<option value="">Freitext</option>';
    clients.forEach(client => {
        const selected = client.id === entry.clientId ? 'selected' : '';
        clientOptions += `<option value="${client.id}" ${selected}>${client.name}</option>`;
    });

    clientCell.innerHTML = `
        <select class="edit-input client-select">${clientOptions}</select>
        <input type="text" class="edit-input client-free-text" value="${clientFreeTextValue}" placeholder="Klient (optional)" style="${entry.clientId ? 'display:none;' : ''}">
    `;

    // Dauer
    durationCell.innerHTML = `<input type="text" class="edit-input" value="${durationValue}" placeholder="z.B. 01:15:30">`;

    // Buttons ersetzen
    const actionCell = row.querySelector('td:last-child');
    actionCell.innerHTML = `
        <button onclick="saveEntry(${entryId})">Speichern</button>
        <button onclick="cancelEdit(${entryId})">Abbrechen</button>
    `;

    // Event listener f√ºr das Dropdown
    const clientSelectElement = clientCell.querySelector('.client-select');
    const clientFreeTextInput = clientCell.querySelector('.client-free-text');

    clientSelectElement.addEventListener('change', () => {
        if (clientSelectElement.value === '') {
            clientFreeTextInput.style.display = '';
        } else {
            clientFreeTextInput.style.display = 'none';
        }
    });
}



  function saveEntry(entryId) {
    const entry = timeEntries.find(e => e.id === entryId);
    if (!entry) return;

    const row = document.getElementById(`entry-${entryId}`);
    const newProjectName = row.querySelector('.project-cell input.project-input').value.trim();

    const clientSelectElement = row.querySelector('.client-cell select.client-select');
    const clientFreeTextInput = row.querySelector('.client-cell input.client-free-text');

    const newClientId = clientSelectElement.value ? parseInt(clientSelectElement.value) : null;
    const newClientName = newClientId ? clients.find(c => c.id === newClientId)?.name || '' : '';
    const newClientFreeText = newClientId ? '' : clientFreeTextInput.value.trim();

    const newDurationStr = row.children[4].querySelector('input').value.trim();
    const timeParts = newDurationStr.split(':').map(Number);
    const newDuration = (timeParts[0] * 3600 + timeParts[1] * 60 + timeParts[2]) * 1000;

    // Speichern der neuen Werte
    entry.projectName = newProjectName;
    entry.projectFreeText = newProjectName; // falls gew√ºnscht
    entry.clientId = newClientId;
    entry.clientName = newClientName;
    entry.clientFreeText = newClientFreeText;
    entry.duration = newDuration;

    saveData('timeEntries', timeEntries);
    publishNostrEvent('time-entry', entry);
    updateEntriesTable();
    
    const projectSelect = row.querySelector('.project-cell select.project-select');
const newProjectId = projectSelect ? parseInt(projectSelect.value) : null;
entry.projectId = newProjectId;

}






        function deleteEntry(entryId) {
    if (!confirm('M√∂chtest du diesen Zeiteintrag wirklich l√∂schen?')) return;

    // Finde den Eintrag, bevor er aus dem Array gefiltert wird, um seine Daten zu haben
    const entryToDelete = timeEntries.find(e => e.id === entryId);

    timeEntries = timeEntries.filter(e => e.id !== entryId);
    saveData('timeEntries', timeEntries);
    updateEntriesTable();

    // NEU: Ver√∂ffentliche ein L√∂sch-Event f√ºr den Zeiteintrag
    if (entryToDelete) { // Stelle sicher, dass der Eintrag gefunden wurde
        publishNostrEvent('time-entry-deleted', { id: entryId });
    }
}

     function cancelEdit(entryId) {
    // Einfach nur die Tabelle zur√ºcksetzen
    updateEntriesTable();
}


        function formatDuration(ms) {
            const hours = Math.floor(ms / 3600000);
            const minutes = Math.floor((ms % 3600000) / 60000);
            const seconds = Math.floor((ms % 60000) / 1000);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }



 function exportToPDF() {
    const reportBody = document.getElementById('reportBody');
    if (!reportBody || !reportBody.hasChildNodes()) {
        alert('Bitte zuerst einen Bericht mit Eintr√§gen generieren.');
        return;
    }

    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        if (!doc.autoTable) {
            throw new Error('jsPDF-AutoTable plugin is not loaded correctly.');
        }

        doc.text('Zeiterfassungs-Bericht', 10, 10);

        const rows = Array.from(reportBody.querySelectorAll('tr')).map(row =>
            Array.from(row.querySelectorAll('td')).map(cell => cell.textContent.trim())
        );

        doc.autoTable({
            head: [['Datum', 'Projekt', 'Client', 'Dauer']],
            body: rows,
            startY: 20
        });

        const totalHours = document.getElementById('totalHours').textContent;
        let y = doc.lastAutoTable?.finalY ?? 30;
        doc.text(`Gesamtstunden: ${totalHours}`, 10, y + 10);

        const lightningAddress = localStorage.getItem('lightningAddress');

        if (lightningAddress) {
            y += 20;
            doc.text('Danke f√ºr die Unterst√ºtzung!', 10, y);
            doc.text(`Lightning: ${lightningAddress}`, 10, y + 10);

            // QR-Code-URL
            const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=lightning:${encodeURIComponent(lightningAddress)}`;

            // Lade das Bild und zeichne es ein
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = qrUrl;

            img.onload = function() {
                doc.addImage(img, 'PNG', 10, y + 15, 40, 40);
                doc.save('zeiterfassung_bericht.pdf');
            };
        } else {
            doc.save('zeiterfassung_bericht.pdf');
        }

    } catch (error) {
        console.error("Fehler beim PDF-Export:", error);
        alert("Beim Erstellen der PDF ist ein Fehler aufgetreten: " + error.message);
    }
}





       function toggleSections() {
          
    document.getElementById('loginSection').classList.toggle('hidden', isLoggedIn);
    document.getElementById('timerSection').classList.toggle('hidden', !isLoggedIn);
    document.getElementById('entriesSection').classList.toggle('hidden', !isLoggedIn);
    document.getElementById('projectSection').classList.toggle('hidden', !isLoggedIn);
    document.getElementById('reportSection').classList.toggle('hidden', !isLoggedIn);
    document.getElementById('donationSection').classList.toggle('hidden', !isLoggedIn);
    document.getElementById('contactsSection').classList.toggle('hidden', !isLoggedIn);
   document.getElementById('tabMenu').classList.toggle('hidden', !isLoggedIn);


}


        function startTimer() {
            if (!timerInterval) {
                startTime = Date.now();
                elapsedTime = 0;
                timerInterval = setInterval(updateTimer, 1000);
                document.getElementById('startButton').disabled = true;
                document.getElementById('stopButton').disabled = false;
                window.dispatchEvent(new Event('timer-started'));
            }
        }

     function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
        elapsedTime = Date.now() - startTime;

        const projectSelect = document.getElementById('projectSelect');
        const clientSelect = document.getElementById('clientSelect');

        const projectId = parseInt(projectSelect.value) || null;
        const projectName = projectSelect.selectedIndex >= 0 ? projectSelect.options[projectSelect.selectedIndex].textContent : '';
        const clientId = parseInt(clientSelect.value) || null;
        const clientName = clientSelect.selectedIndex >= 0 ? clientSelect.options[clientSelect.selectedIndex].textContent : '';

        const projectFreeText = document.getElementById('projectFreeText').value || '';
        const clientFreeText = document.getElementById('clientFreeText').value || '';

        const entry = {
            id: Date.now(),
            projectId: projectId,
            clientId: clientId,
            projectName: projectId ? projectName : projectFreeText,
            clientName: clientId ? clientName : clientFreeText,
            projectFreeText: projectId ? '' : projectFreeText,
            clientFreeText: clientId ? '' : clientFreeText,
            start: startTime,
            end: Date.now(),
            duration: elapsedTime
        };

        timeEntries.push(entry);
        saveData('timeEntries', timeEntries);
        publishNostrEvent('time-entry', entry);
        updateEntriesTable();

        // Reset Timer & UI
        elapsedTime = 0;
        startTime = null;
        document.getElementById('timerDisplay').textContent = '00:00:00';
        document.getElementById('startButton').disabled = false;
        document.getElementById('stopButton').disabled = true;
        window.dispatchEvent(new Event('timer-stopped'));
    }
}





        function updateTimer() {
            elapsedTime = Date.now() - startTime;
            const hours = Math.floor(elapsedTime / 3600000);
            const minutes = Math.floor((elapsedTime % 3600000) / 60000);
            const seconds = Math.floor((elapsedTime % 60000) / 1000);
            document.getElementById('timerDisplay').textContent =
                `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function generateNostrKeys() {
            try {
                const privKey = window.NostrTools.generatePrivateKey();
                const nsec = window.NostrTools.nip19.nsecEncode(privKey);
                const pubKey = window.NostrTools.getPublicKey(privKey);
                const npub = window.NostrTools.nip19.npubEncode(pubKey);
                document.getElementById('generatedKeyDisplay').textContent =
                    `Privater Schl√ºssel (sicher speichern!): ${nsec}\n√ñffentlicher Schl√ºssel: ${npub}`;
                document.getElementById('generatedKeyDisplay').classList.remove('hidden');
                document.getElementById('loginError').textContent = 'Schl√ºssel generiert. Bitte importiere den privaten Schl√ºssel in Alby.';
            } catch (err) {
                document.getElementById('loginError').textContent = 'Schl√ºsselgenerierung fehlgeschlagen: ' + err.message;
            }
        }

        function setTodayDate() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('reportDate').value = today;
        }

      function generateReport() {
  const filter = document.getElementById('reportFilter').value;
  const dateInput = document.getElementById('reportDate').value;

  const selectedProjectFilterId = document.getElementById('reportProjectFilter').value;
  const selectedClientFilterId = document.getElementById('reportClientFilter').value;

  if (!dateInput) {
    alert('Bitte ein Datum ausw√§hlen.');
    return;
  }

  const selectedDate = new Date(dateInput);
  selectedDate.setHours(0, 0, 0, 0);
  let startDate, endDate;

  if (filter === 'day') {
    startDate = new Date(selectedDate);
    endDate = new Date(selectedDate);
    endDate.setDate(endDate.getDate() + 1);
  } else if (filter === 'week') {
    startDate = new Date(selectedDate);
    startDate.setDate(startDate.getDate() - startDate.getDay() + 1);
    endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + 7);
  } else if (filter === 'month') {
    startDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
    endDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 1);
  }

  const filteredEntries = timeEntries.filter(entry => {
    if (!entry.start) return false;

    const entryDate = new Date(entry.start);
    entryDate.setHours(0, 0, 0, 0);

    const dateMatch = entryDate >= startDate && entryDate < endDate;
    const projectMatch =
      selectedProjectFilterId === 'all' ||
      String(entry.projectId || '') === selectedProjectFilterId;

    const clientMatch =
      selectedClientFilterId === 'all' ||
      String(entry.clientId || '') === selectedClientFilterId;

    return dateMatch && projectMatch && clientMatch;
  });

  filteredEntries.sort((a, b) => b.start - a.start);

  const reportBody = document.getElementById('reportBody');
  reportBody.innerHTML = '';
  let totalDuration = 0;

  if (filteredEntries.length === 0) {
    reportBody.innerHTML = '<tr><td colspan="4">Keine Eintr√§ge f√ºr den Zeitraum und die ausgew√§hlten Filter gefunden.</td></tr>';
  } else {
    filteredEntries.forEach(entry => {
      const projectDisplay = entry.projectName || entry.projectFreeText || 'Kein Projekt';
      const clientDisplay = entry.clientName || entry.clientFreeText || 'Kein Client';
      const durationFormatted = formatDuration(entry.duration);

      totalDuration += entry.duration;

      reportBody.innerHTML += `
        <tr>
          <td>${new Date(entry.start).toLocaleDateString('de-DE')}</td>
          <td>${projectDisplay}</td>
          <td>${clientDisplay}</td>
          <td>${durationFormatted}</td>
        </tr>
      `;
    });
  }

  document.getElementById('totalHours').textContent = formatDuration(totalDuration);
  document.getElementById('reportTable').classList.remove('hidden');
}





async function fetchNostrEvents() {
    const filter = { kinds: [30000, 0, 1, 3], authors: [publicKey] };
    const maxTries = 7;
    const waitTime = 2000;
    let allEvents = [];

    for (let attempt = 1; attempt <= maxTries; attempt++) {
        try {
            allEvents = await pool.list(relays, [filter]);
            console.log(`üîÑ Versuch ${attempt}, erhaltene Events: ${allEvents.length}`);

            if (allEvents.length > 0) break;
            await new Promise(res => setTimeout(res, waitTime));
        } catch (e) {
            console.warn(`‚ùå Fehler beim Abrufen der Events (Versuch ${attempt}):`, e.message);
            await new Promise(res => setTimeout(res, waitTime));
        }
    }

    if (allEvents.length === 0) {
        showStatus('‚ö†Ô∏è Es konnten keine Events von den Relays geladen werden.');
    } else {
        console.log(`‚úÖ Events geladen:`, allEvents.length);
        processFetchedEvents(allEvents);
    }
}








async function processFetchedEvents(events) {
    events.sort((a, b) => a.created_at - b.created_at);

    const latestTimeEntries = new Map();
    const latestProjects = new Map();
    const latestClients = new Map();
    const latestTodos = new Map();

    const deletedProjectIds = new Set();
    const deletedClientIds = new Set();
    const deletedTimeEntryIds = new Set();
    const deletedTodoIds = new Set();

    for (const event of events) {
        const tag = event.tags.find(tag => tag[0] === 't');
        const type = tag?.[1];

        if (!type) continue;

        let data;
        try {
            data = JSON.parse(event.content);
        } catch (e) {
            console.warn('[Nostr] Fehler beim Parsen von Content:', event.content);
            continue;
        }

        if (data.id) data.id = parseInt(data.id);
        if (data.projectId) data.projectId = parseInt(data.projectId);
        if (data.clientId) data.clientId = parseInt(data.clientId);

        switch (type) {
            case 'project-deleted':
                deletedProjectIds.add(data.id);
                latestProjects.delete(data.id);
                break;
            case 'client-deleted':
                deletedClientIds.add(data.id);
                latestClients.delete(data.id);
                break;
            case 'time-entry-deleted':
                deletedTimeEntryIds.add(data.id);
                latestTimeEntries.delete(data.id);
                break;
            case 'todo-deleted':
                deletedTodoIds.add(data.id);
                latestTodos.delete(data.id);
                break;
            case 'project': {
                const existing = latestProjects.get(data.id);
                if (!existing || event.created_at > existing._created_at) {
                    data._created_at = event.created_at;
                    latestProjects.set(data.id, data);
                }
                break;
            }
            case 'client': {
                const existing = latestClients.get(data.id);
                if (!existing || event.created_at > existing._created_at) {
                    data._created_at = event.created_at;
                    latestClients.set(data.id, data);
                }
                break;
            }
            case 'time-entry': {
                const existing = latestTimeEntries.get(data.id);
                if (!existing || event.created_at > existing._created_at) {
                    data._created_at = event.created_at;
                    latestTimeEntries.set(data.id, data);
                }
                break;
            }
            case 'todo': {
                const existing = latestTodos.get(data.id);
                if (!existing || event.created_at > existing._created_at) {
                    data._created_at = event.created_at;
                    latestTodos.set(data.id, data);
                }
                break;
            }
        }
    }

    // FILTER: nur g√ºltige Objekte √ºbernehmen
    timeEntries = Array.from(latestTimeEntries.values()).filter(e =>
        !deletedTimeEntryIds.has(e.id) &&
        (!e.projectId || !deletedProjectIds.has(e.projectId)) &&
        (!e.clientId  || !deletedClientIds.has(e.clientId))
    );

    projects = Array.from(latestProjects.values()).filter(p => !deletedProjectIds.has(p.id));
    clients  = Array.from(latestClients.values()).filter(c => !deletedClientIds.has(c.id));
    todos    = Array.from(latestTodos.values()).filter(t => !deletedTodoIds.has(t.id));

    // Speicher leeren & neu schreiben
    localStorage.removeItem('projects');
    localStorage.removeItem('clients');
    localStorage.removeItem('timeEntries');
    localStorage.removeItem('todos');

    saveData('projects', projects);
    saveData('clients', clients);
    saveData('timeEntries', timeEntries);
    saveData('todos', todos);

    // UI aktualisieren
    updateSelectOptions();
    updateLists();
    updateEntriesTable();
    updateReportFilterOptions();
    renderTodos();

    window.dispatchEvent(new Event('data-loaded'));

    console.log(`‚úÖ Events verarbeitet:
        Projekte: ${projects.length},
        Clients: ${clients.length},
        Zeiteintr√§ge: ${timeEntries.length},
        Todos: ${todos.length}`);
}








 // Hilfsfunktion, um zu erkennen, ob ein Relay ein privates ist
function isPrivateRelay(url) {
  return url.includes('.onion') || url.includes('mein-privat-relay.com'); // <-- ggf. weitere Kriterien erg√§nzen
}

async function publishNostrEvent(type, data) {
  if (!publicKey || !Array.isArray(relays) || relays.length === 0 || !window.nostr) {
    console.warn('‚ö†Ô∏è publishNostrEvent √ºbersprungen ‚Äì unvollst√§ndige Umgebung.');
    return;
  }

  // Standardm√§√üig: alle gew√§hlten Relays
  let relaysToSend = relays;

  // Pr√ºfe: Sind ALLE verbundenen Relays private?
  const onlyPrivate = relays.every(isPrivateRelay);

  if (onlyPrivate) {
    // Sende ausschlie√ülich an die privaten Relays
    relaysToSend = relays.filter(isPrivateRelay);
    console.log('üîê Nur mit privaten Relays verbunden ‚Äì sende ausschlie√ülich dorthin:', relaysToSend);
  } else {
    console.log('üåê √ñffentliche Relays erkannt ‚Äì sende an alle aktiven Relays:', relaysToSend);
  }

  const event = {
    kind: 30000,
    pubkey: publicKey,
    created_at: Math.floor(Date.now() / 1000),
    tags: [['t', type]],
    content: JSON.stringify(data)
  };

  try {
    const signed = await window.nostr.signEvent(event);
    await pool.publish(relaysToSend, signed);
    console.log(`‚úÖ Event "${type}" erfolgreich ver√∂ffentlicht an:`, relaysToSend);
  } catch (e) {
    console.warn('‚ùå publishNostrEvent fehlgeschlagen:', e.message);
    document.getElementById('loginError').textContent = 'Fehler beim Ver√∂ffentlichen des Nostr-Events.';
  }
}













        async function makeLightningDonation() {
    try {
        if (!window.webln) {
            throw new Error('WebLN nicht verf√ºgbar. Installiere z.B. Alby.');
        }

        await window.webln.enable();

        // üìç Hier neue Adresse aus dem localStorage holen:
        const lightningAddress = localStorage.getItem('lightningAddress');
        if (!lightningAddress) {
            throw new Error('Bitte erst oben deine Lightning-Adresse speichern.');
        }

        const amount = parseInt(document.getElementById('donationAmount').value) || 1000;
        const username = lightningAddress.split('@')[0];
        const lnurlData = await fetch(`https://getalby.com/.well-known/lnurlp/${username}`).then(res => res.json());
        const invoiceResponse = await fetch(`${lnurlData.callback}?amount=${amount * 1000}`).then(res => res.json());
        await window.webln.sendPayment(invoiceResponse.pr);

        document.getElementById('donationError').textContent = 'Danke f√ºr deine Spende!';
    } catch (err) {
        document.getElementById('donationError').textContent = 'Spende fehlgeschlagen: ' + err.message;
    }
}


        function addProject() {
            const input = document.getElementById('projectNameInput');
            const name = input.value.trim();
            if (!name) return;
            const id = Date.now();
            projects.push({ id, name });
            saveData('projects', projects);
            updateSelectOptions();
            updateLists();
            input.value = '';
            publishNostrEvent('project', { id, name });
              updateReportFilterOptions(); // <-- NEU: Aktualisiert die Report-Filter
        }

        function addClient() {
            const input = document.getElementById('clientNameInput');
            const name = input.value.trim();
            if (!name) return;
            const id = Date.now();
            clients.push({ id, name });
            saveData('clients', clients);
            updateSelectOptions();
            updateLists();
            input.value = '';
            publishNostrEvent('client', { id, name });
            updateReportFilterOptions(); // <-- NEU: Aktualisiert die Report-Filter
        }
        
        
          function deleteProject(projectId) {
            if (!confirm('M√∂chtest du dieses Projekt wirklich l√∂schen? Verkn√ºpfte Zeiteintr√§ge bleiben erhalten, aber als Freitext.')) return;
            const project = projects.find(p => p.id === projectId);
            projects = projects.filter(p => p.id !== projectId);
            timeEntries.forEach(entry => {
                if (entry.projectId === projectId) {
                    entry.projectFreeText = project?.name || '';
                    entry.projectId = null;
                    publishNostrEvent('time-entry', entry);
                }
            });
            saveData('projects', projects);
            saveData('timeEntries', timeEntries);
            publishNostrEvent('project-deleted', { id: projectId });
            updateSelectOptions();
            updateLists();
            updateEntriesTable();
        }

        function deleteClient(clientId) {
            if (!confirm('M√∂chtest du diesen Client wirklich l√∂schen? Verkn√ºpfte Zeiteintr√§ge bleiben erhalten, aber als Freitext.')) return;
            const client = clients.find(c => c.id === clientId);
            clients = clients.filter(c => c.id !== clientId);
            timeEntries.forEach(entry => {
                if (entry.clientId === clientId) {
                    entry.clientFreeText = client?.name || '';
                    entry.clientId = null;
                    publishNostrEvent('time-entry', entry);
                }
            });
            saveData('clients', clients);
            saveData('timeEntries', timeEntries);
            publishNostrEvent('client-deleted', { id: clientId });
            updateSelectOptions();
            updateLists();
            updateEntriesTable();
        }








  (function enableTimerPersistence() {
    const TIMER_KEY = 'persistentTimerStart';
    const PROJECT_KEY = 'persistentProject';
    const CLIENT_KEY = 'persistentClient';

    // ‚ö° Wird automatisch aufgerufen, nachdem die Daten aus Nostr geladen wurden:
    window.addEventListener('data-loaded', () => {
        const savedStart = sessionStorage.getItem(TIMER_KEY);
        const savedProject = sessionStorage.getItem(PROJECT_KEY);
        const savedClient = sessionStorage.getItem(CLIENT_KEY);

        if (savedStart && !timerInterval) {
            // Starte Timer automatisch wieder
            startTime = parseInt(savedStart, 10);
            timerInterval = setInterval(updateTimer, 1000);
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false;

            // Projekt wiederherstellen
            if (savedProject) {
                const { id, freeText } = JSON.parse(savedProject);
                document.getElementById('projectSelect').value = id || '';
                document.getElementById('projectFreeText').value = freeText || '';
                document.getElementById('projectFreeText').classList.toggle('hidden', !!id);
            }

            // Klient wiederherstellen
            if (savedClient) {
                const { id, freeText } = JSON.parse(savedClient);
                document.getElementById('clientSelect').value = id || '';
                document.getElementById('clientFreeText').value = freeText || '';
                document.getElementById('clientFreeText').classList.toggle('hidden', !!id);
            }

            console.log('[Timer] Timer beim Reload automatisch wiederhergestellt.');
        }
    });

    // ‚ö° Schreibt die aktuellen Werte beim Starten in sessionStorage
    window.addEventListener('timer-started', () => {
        sessionStorage.setItem(TIMER_KEY, String(startTime));
        sessionStorage.setItem(PROJECT_KEY, JSON.stringify({
            id: document.getElementById('projectSelect').value || null,
            freeText: document.getElementById('projectFreeText').value || ''
        }));
        sessionStorage.setItem(CLIENT_KEY, JSON.stringify({
            id: document.getElementById('clientSelect').value || null,
            freeText: document.getElementById('clientFreeText').value || ''
        }));
        console.log('[Timer] Timer-Start und Werte gespeichert.');
    });

    // ‚ö° L√∂scht die Werte beim Stoppen aus sessionStorage
    window.addEventListener('timer-stopped', () => {
        sessionStorage.removeItem(TIMER_KEY);
        sessionStorage.removeItem(PROJECT_KEY);
        sessionStorage.removeItem(CLIENT_KEY);
        console.log('[Timer] SessionStorage gel√∂scht.');
    });
})();





function saveLightningAddress(event) {
    const addr = document.getElementById('lightningAddressInput').value.trim();
    if (!addr) {
        alert('Bitte eine Lightning-Adresse eingeben.');
        return;
    }

    // Speichern
    localStorage.setItem('lightningAddress', addr);

    // Eingabefeld & Button ausblenden
    document.getElementById('lightningAddressInputContainer').classList.add('hidden');

    // Best√§tigungsnachricht zeigen
    const confirmation = document.getElementById('lightningAddressConfirmation');
    confirmation.textContent = `‚úÖ Lightning-Adresse aktiviert (${addr})`;
    confirmation.classList.remove('hidden');

    // Erfolgsmeldung
     alert('Lightning-Adresse gespeichert und aktiviert!');

    // kein Default-Button-Verhalten
    event.preventDefault();
}



function editLightningAddress() {
    // Zeige Eingabefeld und Button wieder
    document.getElementById('lightningAddressInputContainer').classList.remove('hidden');

    // Bereits gespeicherte Adresse ins Eingabefeld √ºbernehmen
    const savedAddress = localStorage.getItem('lightningAddress');
    document.getElementById('lightningAddressInput').value = savedAddress || '';

    // Best√§tigung und Edit-Button ausblenden
    document.getElementById('lightningAddressConfirmation').classList.add('hidden');
    document.getElementById('editLightningAddressButton').classList.add('hidden');
}





// Hilfsfunktion f√ºr Statusmeldungen in der UI
function showStatus(message) {
    let statusEl = document.getElementById('statusMessage');
    if (!statusEl) {
        statusEl = document.createElement('p');
        statusEl.id = 'statusMessage';
        statusEl.style.cssText = `
            padding: 0.5rem;
            background: #222;
            color: white;
            border-radius: 4px;
            margin: 0.5rem 0;
        `;
        document.querySelector('.container').prepend(statusEl); // oben in die .container einf√ºgen
    }
    statusEl.textContent = message;
}



async function loadMyContactsAndProfiles() {
    showStatus('‚è≥ Lade Kontakte aus allen gew√§hlten Relays ...');

    let attempts = 0;
    const maxAttempts = 9;
    const delayMs = 4000;
    let allContactsEvents = [];

    while (attempts < maxAttempts) {
        attempts++;
        try {
            allContactsEvents = await pool.list(relays, [{ kinds: [3], authors: [publicKey] }]);
            console.log(`‚ÑπÔ∏è [loadMyContactsAndProfiles] Versuch ${attempts}: ${allContactsEvents.length} gefunden.`);
            if (allContactsEvents.length > 0) break;
            await new Promise(res => setTimeout(res, delayMs));
        } catch (error) {
            console.error(`‚ùå [loadMyContactsAndProfiles] Fehler beim Abrufen der Kontakte (Versuch ${attempts}):`, error);
            await new Promise(res => setTimeout(res, delayMs));
        }
    }

    if (allContactsEvents.length === 0) {
        showStatus('‚ö†Ô∏è Keine Kontakte gefunden.');
        return;
    }

    const contactsEvent = allContactsEvents.sort((a, b) => b.created_at - a.created_at)[0];
    const nostrContacts = contactsEvent.tags.filter(tag => tag[0] === 'p').map(tag => tag[1]);
    localStorage.setItem('myContacts', JSON.stringify(nostrContacts));
    showStatus(`‚úÖ ${nostrContacts.length} Kontakte gefunden.`);

    await loadProfilesForContacts(nostrContacts);
}








// Liste der √∂ffentlichen Read-Only-Relays
const publicReadOnlyRelays = [
  "wss://nos.lol",
  "wss://relay.nostr.band",
  "wss://relay.snort.social",
  "wss://relay.damus.io",
  "wss://nostr.wine",
  "wss://cache2.primal.net/v1",
  "wss://nostr.fmt.wiz.biz"
];

// Anzahl Kontakte pro Einzelabfrage
const chunkSize = 200;

async function loadProfilesForContacts(nostrContacts) {
  if (!Array.isArray(nostrContacts) || nostrContacts.length === 0) {
    console.warn('‚ö†Ô∏è Keine Kontakte √ºbergeben.');
    return;
  }

  const profileMap = new Map();
  const mergedRelays = publicReadOnlyRelays; // Nur lesezweck!

  try {
    console.log(`üîç Lade Profile f√ºr ${nostrContacts.length} Kontakte von ${mergedRelays.length} Relays...`);
    showStatus('‚è≥ Lade Nostr-Profile...');

    const allProfileEvents = [];

    // Alle Kontakte in Bl√∂cke (Chunks) z.‚ÄØB. 200er aufteilen
    for (let i = 0; i < nostrContacts.length; i += chunkSize) {
      const chunk = nostrContacts.slice(i, i + chunkSize);

      // F√ºr jedes Relay ‚Üí separat holen
      const perRelayFetches = mergedRelays.map(async (relay) => {
        try {
          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 8000));
          const fetchPromise = pool.list([relay], [{ kinds: [0], authors: chunk }]);

          const events = await Promise.race([fetchPromise, timeoutPromise]);
          console.log(`‚úì ${relay}: ${events.length} Profile geladen (f√ºr Block ab ${i})`);

          // Annotiere jedes Event mit dem Relay (optional f√ºrs Logging)
          for (const ev of events) {
            ev._relay = relay;
          }

          return events;
        } catch (err) {
          console.warn(`‚ö†Ô∏è ${relay}: Fehler bei Chunk ${i}/${nostrContacts.length}: ${err.message}`);
          return [];
        }
      });

      // Warte auf alle Relays f√ºr diesen Chunk
      const chunkResults = await Promise.all(perRelayFetches);
      const flatEvents = chunkResults.flat();
      allProfileEvents.push(...flatEvents);
    }

    console.log(`üéØ Gesamt erhaltene Events: ${allProfileEvents.length}`);

    // Verarbeite alle zusammengetragenen Events
    for (const event of allProfileEvents) {
      const pubkey = event.pubkey;
      let profile;

      try {
        profile = JSON.parse(event.content);
      } catch (e) {
        continue;
      }

      // N√ºtzliche Felder pr√ºfen
      const hasUseful = profile?.name || profile?.display_name || profile?.picture || profile?.lud16 || profile?.lnurl || profile?.nip05;
      if (!hasUseful) continue;

      // Bewertungsfunktion
      const getScore = (p) => [
        p.display_name,
        p.name,
        p.picture,
        p.lud16,
        p.lnurl,
        p.nip05,
        p.about
      ].filter(Boolean).length;

      const newScore = getScore(profile);

      const existing = profileMap.get(pubkey);
      if (!existing || event.created_at > existing._created_at && newScore >= existing._score) {
        profileMap.set(pubkey, {
          ...profile,
          _created_at: event.created_at,
          _score: newScore,
          _relay: event._relay || null
        });
      }
    }

    // Kontaktliste f√ºrs UI zusammenbauen
    allContacts = nostrContacts.map(pubkey => ({
      pubkey,
      profile: profileMap.get(pubkey) || null
    }));

    renderFilteredContacts();

    const validCount = allContacts.filter(c => c.profile).length;
    console.log(`‚úÖ ${validCount} g√ºltige Profile geladen`);
    showStatus(`‚úÖ ${validCount} Kontakte mit Profil geladen ‚úÖ`);
  } catch (err) {
    console.error('‚ùå Fehler beim Laden der Profile:', err);
    showStatus('‚ö†Ô∏è Profil-Ladevorgang fehlgeschlagen');
  }
}








function renderFilteredContacts() {
    const container = document.getElementById('contactsContainer');
    container.innerHTML = ''; // Liste leeren

    const onlyWithLightning = document.getElementById('filterWithLightning').checked;
    const searchQuery = document.getElementById('contactSearchInput').value.trim().toLowerCase();

    const filtered = allContacts
        .filter(({ profile }) => {
            if (onlyWithLightning && !(profile?.lud16 || profile?.lnurl)) {
                return false;
            }

            if (searchQuery) {
                const name =
                    profile?.display_name ||
                    profile?.name ||
                    profile?.username ||
                    '';
                return name.toLowerCase().includes(searchQuery);
            }

            return true;
        })
        .sort((a, b) => {
            const nameA = (a.profile?.display_name || a.profile?.name || a.profile?.username || '').toLowerCase();
            const nameB = (b.profile?.display_name || b.profile?.name || b.profile?.username || '').toLowerCase();
            return nameA.localeCompare(nameB);
        });

    if (filtered.length === 0) {
        container.innerHTML = `<p style="color:#666;">Keine Kontakte gefunden.</p>`;
        return;
    }

    filtered.forEach(({ profile, pubkey }) => {
        displayContact(profile, pubkey);
    });
}






function displayContact(profile, pubkey) {
    const container = document.getElementById('contactsContainer');

    // Kontakt bereits angezeigt? ‚Üí abbrechen
    if (document.getElementById(`contact-${pubkey}`)) {
        return;
    }

    const div = document.createElement('div');
    div.id = `contact-${pubkey}`;

    const nameToShow =
        profile?.display_name ||
        profile?.name ||
        profile?.username ||
        pubkey.slice(0, 8) + '‚Ä¶';

    const pictureUrl = profile?.picture || 'https://via.placeholder.com/40';
    const lightning = profile?.lud16 || profile?.lnurl || '';

    div.innerHTML = `
        <div style="display:flex; align-items:center; gap:0.5rem; margin-bottom:0.5rem;">
            <img src="${pictureUrl}" alt="${nameToShow}" 
                 style="width:40px; height:40px; border-radius:50%;"
                 onerror="this.onerror=null; this.src='https://i.nostr.build/y53o2A9HR75zVyg6.jpg'">
            <strong>${nameToShow}</strong>
        </div>
        <button onclick="sendTipTo('${lightning}', '${nameToShow}')" ${lightning ? '' : 'disabled'}>üí∏ Danke senden</button>
        <button onclick="addAsClient('${nameToShow}', '${pubkey}', '${lightning}')">‚ûï Als Client hinzuf√ºgen</button>
    `;

    container.appendChild(div);
}







async function sendTipTo(lightningAddress, name) {
    if (!lightningAddress || !lightningAddress.includes('@')) {
        alert(`‚ö†Ô∏è Ung√ºltige Lightning-Adresse f√ºr ${name}`);
        return;
    }

    const buttons = document.querySelectorAll(`button[onclick*="${lightningAddress}"]`);
    buttons.forEach(btn => {
        btn.disabled = true;
        btn.textContent = "‚è≥ Senden ‚Ä¶";
    });

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 10000); // 10 Sekunden Timeout

    try {
        await window.webln.enable();

        const [namePart, domain] = lightningAddress.split('@');
        const lnurlUrl = `https://${domain}/.well-known/lnurlp/${namePart}`;

        const response = await fetch(lnurlUrl, { signal: controller.signal });
        if (!response.ok) throw new Error(`LNURL-Server antwortete mit Status ${response.status}`);
        const lnurlData = await response.json();

        if (!lnurlData.callback || lnurlData.status === 'ERROR') {
            throw new Error('Ung√ºltige Antwort vom LNURL-Server.');
        }

        const amountInput = prompt(`Wieviele Sats m√∂chtest du an ${name} senden?`, "1000");

        if (amountInput === null) {
            throw new Error('__ABORTED__'); // Spezieller Marker f√ºr Abbruch
        }

        const amount = parseInt(amountInput);
        if (isNaN(amount) || amount < 1) {
            throw new Error('__INVALID_AMOUNT__');
        }

        const invoiceResponse = await fetch(`${lnurlData.callback}?amount=${amount * 1000}`, { signal: controller.signal });
        const invoiceData = await invoiceResponse.json();

        if (!invoiceData.pr) throw new Error('Zahlungsanforderung fehlgeschlagen.');

        await window.webln.sendPayment(invoiceData.pr);
        alert(`‚úÖ Zahlung erfolgreich an ${name} gesendet!`);

    } catch (error) {
        if (error.name === 'AbortError') {
            alert(`‚è±Ô∏è Der Zahlungsvorgang an ${name} hat zu lange gedauert (Timeout).`);
        } else if (error.message === '__ABORTED__') {
            alert(`‚ö†Ô∏è Zahlung an ${name} wurde abgebrochen.`);
        } else if (error.message === '__INVALID_AMOUNT__') {
            alert(`‚ùå Ung√ºltiger Betrag ‚Äì Zahlung an ${name} wurde nicht ausgef√ºhrt.`);
        } else {
            alert(`‚ùå Zahlung an ${name} fehlgeschlagen: ${error.message}`);
        }
        console.error(error);
    } finally {
        clearTimeout(timeout);
        buttons.forEach(btn => {
            btn.disabled = false;
            btn.textContent = "üí∏ Danke senden";
        });
    }
}







function addAsClient(name, pubkey, lightning) {
    // Lade die globalen Clients aus localStorage
    clients = JSON.parse(localStorage.getItem('clients')) || [];

    // Doppelte verhindern
    if (clients.some(client => client.pubkey === pubkey)) {
        alert(`${name} ist bereits als Client vorhanden.`);
        return;
    }

    const id = Date.now();
    const newClient = { id, name, pubkey, lightning };
    clients.push(newClient);

    // Speichern und UI updaten
    saveData('clients', clients); 
    updateSelectOptions();
    updateLists();
    updateReportFilterOptions();

    // üìç Client auch ans Nostr-Relay ver√∂ffentlichen
    publishNostrEvent('client', newClient);

    alert(`‚úÖ ${name} als Client hinzugef√ºgt und als Event ver√∂ffentlicht!`);
}









async function checkRelayHealth(relays, delayMs = 1500) {
    const healthy = [];

    for (const url of relays) {
        try {
            const relay = pool.ensureRelay(url);
            await new Promise(res => setTimeout(res, delayMs));
            healthy.push(url);
            console.log(`‚úÖ Relay in Ordnung: ${url}`);
        } catch (err) {
            console.warn(`‚ùå Relay nicht erreichbar: ${url} (${err.message})`);
        }
    }

    return healthy;
}








// Publiziere alle Kontakte automatisch auf dem privaten Relay
async function publishContactsToPrivateRelay(nostrContacts) {
    try {
        if (!nostrContacts || nostrContacts.length === 0) {
            console.log('‚ÑπÔ∏è Keine Kontakte gefunden, nichts zu ver√∂ffentlichen.');
            return;
        }

        const tags = nostrContacts.map(pubkey => ['p', pubkey]);
        const event = {
            kind: 3,
            pubkey: publicKey,
            created_at: Math.floor(Date.now() / 1000),
            tags,
            content: ''
        };
        const signedEvent = await window.nostr.signEvent(event);

        // Sende nur an Dein privates Relay
        const privateRelays = relays.filter(url => url.includes('.onion'));
        if (privateRelays.length === 0) {
            console.log('‚ÑπÔ∏è Kein privates Relay gefunden.');
            return;
        }

        await pool.publish(privateRelays, signedEvent);
        console.log('‚úÖ Neueste Kontakte erfolgreich an private Relays ver√∂ffentlicht.');
    } catch (error) {
        console.error('‚ùå Fehler beim Ver√∂ffentlichen der Kontakte:', error);
    }
}







async function checkContactsOnPrivateRelay() {
    const privateRelays = relays.filter(url => url.includes('.onion') || url.includes('mein-privat-relay.com'));
    if (privateRelays.length === 0) {
        console.log('‚ùå Kein privates Relay in der Relays-Liste gefunden.');
        return;
    }

    try {
        const events = await pool.list(privateRelays, [
            { kinds: [3], authors: [publicKey] }
        ]);

        if (events.length === 0) {
            console.log('‚ÑπÔ∏è Keine Kontakte auf dem privaten Relay gefunden.');
            return;
        }

        console.log(`‚úÖ ${events.length} Kontakte-Events gefunden auf dem privaten Relay:`);
        events.sort((a, b) => b.created_at - a.created_at).forEach((ev, index) => {
            console.log(`#${index + 1}`, ev.created_at, ev.tags);
        });

        // Kontakte extrahieren
        const latestEvent = events.sort((a,b) => b.created_at - a.created_at)[0];
        const nostrContacts = latestEvent.tags
            .filter(tag => tag[0] === 'p')
            .map(tag => tag[1]);

        console.log('Kontakte aus privatem Relay:', nostrContacts);

        // Jetzt zus√§tzlich: Profile von √∂ffentlichen Relays holen und ins private senden
        const publicRelays = relays.filter(r => !r.includes('.onion') && !r.includes('mein-privat-relay.com'));

        for (const pubkey of nostrContacts) {
            try {
                const profileEvents = await pool.list(publicRelays, [
                    { kinds: [0], authors: [pubkey] }
                ]);

                if (profileEvents.length === 0) {
                    console.log(`‚ùå Kein Profil gefunden f√ºr ${pubkey}`);
                    continue;
                }

                const latestProfileEvent = profileEvents.sort((a, b) => b.created_at - a.created_at)[0];

                await pool.publish(privateRelays, latestProfileEvent);
                console.log(`‚úÖ Profil ver√∂ffentlicht f√ºr ${pubkey} an privates Relay`);

            } catch (err) {
                console.warn(`‚ö†Ô∏è Fehler beim Verarbeiten von ${pubkey}:`, err);
            }
        }

        alert("Profile wurden erfolgreich an dein privates Relay √ºbertragen.");

    } catch (err) {
        console.error('‚ùå Fehler beim Abrufen der Kontakte vom privaten Relay:', err);
    }
}







// hier startet todoTab
let todos = JSON.parse(localStorage.getItem('todos') || '[]');

function addTodo() {
  const title = document.getElementById('todoTitleInput').value.trim();
  const dueDate = document.getElementById('todoDueDateInput').value;
  const clientId = parseInt(document.getElementById('todoClientSelect').value) || null;

  if (!title) return;

  const todo = {
    id: Date.now(),
    title,
    dueDate,
    done: false,
    clientId
  };

  todos.push(todo);
  saveData('todos', todos);
  publishNostrEvent('todo', todo);
  renderTodos();

  document.getElementById('todoTitleInput').value = '';
  document.getElementById('todoDueDateInput').value = '';
  document.getElementById('todoClientSelect').value = '';
}


function renderTodos() {
  const list = document.getElementById('todoList');
  list.innerHTML = '';

  if (todos.length === 0) {
    list.innerHTML = '<li>Keine Aufgaben</li>';
    return;
  }

  todos.forEach(todo => {
    const client = clients.find(c => c.id === todo.clientId);
    const clientLabel = client ? ` ‚Äì <em>${client.name}</em>` : '';
    const li = document.createElement('li');

    li.innerHTML = `
      <input type="checkbox" ${todo.done ? 'checked' : ''} onchange="toggleTodoDone(${todo.id})">
      <span style="text-decoration:${todo.done ? 'line-through' : 'none'}">${todo.title}</span>
      ${todo.dueDate ? `<small> (f√§llig: ${todo.dueDate})</small>` : ''}
      ${clientLabel}
      <button onclick="deleteTodo(${todo.id})">üóëÔ∏è</button>
    `;

    list.appendChild(li);
  });
  
  updateProgressBar();
}


function toggleTodoDone(id) {
    const todo = todos.find(t => t.id === id);
    if (todo) {
        todo.done = !todo.done;
        saveData('todos', todos);
        publishNostrEvent('todo', todo);
        renderTodos();
    }
}

function deleteTodo(id) {
    if (!confirm('Wirklich l√∂schen?')) return;
    todos = todos.filter(t => t.id !== id);
    saveData('todos', todos);
    publishNostrEvent('todo-deleted', { id });
    renderTodos();
}


function updateProgressBar() {
  const done = todos.filter(t => t.done).length;
  const total = todos.length || 1;
  const percent = (done / total) * 100;
  document.getElementById('todoProgress').style.width = percent + '%';
}




    </script>
    
<!--<button id="checkPrivateRelayContactsButton" onclick="checkContactsOnPrivateRelay()">
    Kontakte pr√ºfen
</button> -->

    
</body>
</html>
